
# 硬件解决方案
解决此问题有软件办法和硬件办法。硬件办法能动态地识别出不一致产生的条件并予以及时处理，从而使cache的使用有很高的效率。并且此办法对程序员和系统软件开发人员是透明的，减轻了软件研制负担，从而普遍被采用。 

# MESI 协议（硬件解决方案）
　　MESI协议是一种采用写--无效方式的监听协议。
它要求每个cache行有两个状态位，用于描述该行当前是处于修改态（M）、专有态（E）、共享态（S）或者无效态（I）中的哪种状态，从而决定它的读/写操作行为。这四种状态的定义是：  　　
1. 修改态（Modified）－－此cache行已被修改过（脏行），内容已不同于主存并且 为此cache专有；  　　
2. 专有态（Exclusive）－－此cache行内容同于主存，但不出现于其它cache中；  　　
3. 共享态（Shared）－－此cache行内容同于主存，但也出现于其它cache中；  　　
4. 无效态（Invalid）－－此cache行内容无效（空行）。  　　
## 总线监听（CPU 高速缓存监听总线）
MESI协议适合以总线为互连机构的多处理器系统。各cache控制器除负责响应自己CPU的内存读写操作（包括读/写命中与未命中）外，还要负责监听总线上的其它CPU的内存读写活动（包括读监听命中与写监听命中）并对自己的cache予以相应处理。所有这些处理过程要维护cache一致性，必须符合MESI协议状态转换规则。
## 状态转化
缓存行有4种不同的状态:

* 已修改Modified (M)
缓存行是脏的（dirty），与主存的值不同。如果别的CPU内核要读主存这块数据，该缓存行必须回写到主存，状态变为共享(S).
* 独占Exclusive (E)
缓存行只在当前缓存中，但是干净的（clean）--缓存数据同于主存数据。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态。
* 共享Shared (S)
缓存行也存在于其它缓存中且是干净的。缓存行可以在任意时刻抛弃。
* 无效Invalid (I)
缓存行是无效的
任意一对缓存，对应缓存行的相容关系:

| |M |E |S |I |
|:--|:--|:--|:--|:--|
|M |X |X |X |✔️ |
|E |X |X |X |✔️ |
|S | X |X  |✔️ |✔️ |
|I | ✔️| ✔️|✔️ |✔️ |
				
当块标记为 M (已修改), 在其他缓存中的数据副本被标记为I(无效).

## 状态转换实现方式
有限状态自动机的状态转换结束两种刺激：缓存所在处理器的读写；其他处理器的读写。总线请求被总线窥探器监视。

处理器对缓存的请求:

1. PrRd: 处理器请求读一个缓存块
2. PrWr: 处理器请求写一个缓存块

总线对缓存的请求:

1. BusRd: 窥探器请求指出其他处理器请求读一个缓存块
2. BusRdX: 窥探器请求指出其他处理器请求写一个该处理器不拥有的缓存块
3. BusUpgr: 窥探器请求指出其他处理器请求写一个该处理器拥有的缓存块
4. Flush: 窥探器请求指出请求回写整个缓存到主存
5. FlushOpt: 窥探器请求指出整个缓存块被发到总线以发送给另外一个处理器（缓存到缓存的复制）
