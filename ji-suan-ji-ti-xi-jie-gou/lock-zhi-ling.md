最核心：lock 前缀指令的目的——保证原子性

---

# 关于原子操作
1. 处理器保证从内存中读写一个 byte 是原子的（正在处理时，其他处理器不能访问这个字节的地址）
2. 最新的处理器，可以保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的

# lock前缀指令的两种实现方式
> 来自intel手册

#### 总线锁
早期 CPU，总是采用锁总线的方式。
某个核心遇到 Lock 指令，就触发总线仲裁器，让其把总线完全分给某个核心。
其余的 CPU 核心不能再通过总线与内存通讯。
该核心获取总线锁后，执行操作，最后释放锁。
从而达到“原子性”。
> 总线锁导致其他 CPU 无法工作，代价大

#### 缓存锁
>  Ringbus + MESI 协议，这种技术被称作缓存锁

1. 若干个 CPU 核心通过 ringbus 连在一起
2. 每个核心维护自己的高速 cache 里缓存行的状态
3. 若同一个缓存行同时在多个 CPU 高速 Cache 里，则改缓存行在 cache 里的状态时 S（shared）
4. 一旦某核心修改了这个缓存行，则该核心高速 cache 里这个缓存行的状态变为 M（Modified）
5. 其他核心通过 ringbus 瞬间感知到这个修改，从而把自己高速 cache 里的该缓存行变为 I（invalid），并且从标记为 M 的 cache 里读过来。
6. 同时，这个数据会被原子地写回到主存。
7. 最终，cache 中缓存行的状态恢复为 S（shared）
> 相当于给高速 cache 单独做了一套总线，避免了真的锁总线

# 原子操作示例
#### CAS 操作
对应的指令是 cmpxchg，该指令前加 Lock 来保证原子性


