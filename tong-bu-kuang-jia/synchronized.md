[TOC]

Synchronized隐式地实现同步控制，对开发者透明。

写作思路：
1. 逻辑推理(先说结论，再举证)
2. 实现方式
3. 使用示例

Java SE 1.6对 synchronized 进行了多种优化。
1. 自旋
2. 锁粗化
3. 锁消除
4. 偏向锁 - 轻量级锁 - 重量级锁

---

# synchronized 锁的是一个对象

| 锁的形式|锁定的对象|
|:--|:--|
|普通同步方法|当前实例对象|
|静态同步方法|Class 对象|
|同步代码块|synchronized(参数对象)|

# 锁存在哪里（对象头的 Mark word 里）
## Java 对象头
在 JVM 中每个对象都有个`头`
数组对象：JVM 用3个字宽 word 来存对象头
非数组对象：JVM 用2个字宽 word 存对象头

## 32位系统对象头说明（字宽 word 是32bit）
|长度|内容|说明|
|:--|:--|:--|
|1字宽|Mark Word|hashcode 或锁信息等|
|1字宽|Class Metadata Address|到对象类型数据的指针|
|1字宽|Array Length|数组长度（如果是数组的话，否则没有这个字宽）|

## Mark word 示例
![](/assets/Mark word.png)


> 下面根据锁的四大问题分别进行说明。[《关于锁》](/guan-yu-suo.md)

---

# synchronized 与重量级锁
> synchronized 重量级锁，依赖 OS 的 Mutex 实现。


## 逻辑推理
#### 如果 synchronized 使用重量级锁，会发生什么？

当线程运行至临界区时，从用户态切换到内核态，所有线程挂起，由 OS 来调度，谁执行代码，谁进入阻塞。
#### 有什么问题？运行效率低

* 进入临界区时，总会伴随着用户态到内核态的切换（切换代价高，因为要保存现场，传递参数等）
* 线程直接阻塞（先挂起，后唤醒），这个状态切换代价高

## 重量级锁实现方式
synchronized 代码块的开始处织入 monitorenter
synchronized 代码块的结束处织入 monitorexit
线程运行至 monitorenter 时，查找对象头里的重量级锁的指针，后续就进入 OS 的控制范围内。

---

# 优化 synchronized，使用轻量级锁
> 轻量级锁：先自旋，再进入重量级锁

## 逻辑推理
### 自旋：避免用户态切换内核态，线程挂起后唤醒
如何避免重量级锁的用户态切换内核态，线程立即挂起后唤醒呢？
答：当发现有人已经占用锁时，进入`自旋`（自己做点别的事情，时不时地继续判断是否有人占着锁）
### 自旋的不足：消耗CPU时间
自旋本身是要占用 CPU 时间的，如果别的线程占用锁的时间较短，那么在自旋过程中就能拿到锁，这样就避免了用户态切换内核态，避免了线程挂起唤醒。
### 自旋的限制条件：一定时间内
避免自旋长期消耗 CPU 时间，给其设定了时间范围，超过这个时间，就进入重量级锁。
### 自适应自旋：动态时间限制
锁的竞争情况都是不一样的，JVM 根据不同锁的情况，动态地调整自旋的时间限制。例如这个锁之前的自旋总是能成功，那这次估计也能成功，则时间限制宽松点。

## 轻量级锁实现方式

![](/assets/轻量级锁.png)
> 如果关闭了 JVM 偏向锁，则默认从轻量级锁开始，如有竞争则膨胀到重量级锁

![](/assets/轻量级锁+膨胀.png)

---

# 优化轻量级锁，使用偏向锁
## 逻辑推理
#### 场景：无竞争且同一线程多次获取锁
HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获取。


#### 轻量级锁有什么问题？
针对上述场景，若直接用轻量级锁，则`加锁与释放锁都需要 CAS 操作`。

#### 偏向锁：取消了加锁和解锁时额外的 CAS 操作
> 1. 优化的场景
1. 这里重点强调的是，在一个线程重复进入锁的情况下，其不需要额外的 CAS 操作。其实它第一次获取锁也是需要 CAS的。

![](/assets/偏向锁.png)


# “谁拥有锁”这个信息存在哪里？
1. 偏向锁：ThreadId 放在 Mark word 里
2. 轻量级锁：Mark word 指向线程的 Lock record，在 Lock record 里记录 owner 为拥有锁的线程
3. 重量级锁：放在 monitor 中，直接对标操作系统的 mutex（未确认）

# 偏向锁 - 轻量级锁 - 重量级锁
## 为什么会有这么多锁？
### 重量级锁的问题：切换代价太高
> 两个切换：用户态切换内核态，线程切换到阻塞状态

内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等

### 自旋锁：避免立即进行切换
> 采取延迟策略，在延迟过程中，可能就获取到锁，因而就避免了耗时的切换操作

竞争锁失败后，进入自旋（不阻塞）
自旋的同时，竞争锁
自旋达到限制条件后（次数限制，或时间限制），还未获取到锁，则阻塞（延迟阻塞）

### 自适应自旋锁：优化的自旋锁
自旋的限制条件不再固定，比如这个线程自旋条件是1s 后阻塞，另一个线程的自旋条件是2s 后阻塞。
由 JVM 控制。


## Synchronized 实现互斥
直接使用上述三种形式之一

## Synchronized 实现等待/通知模型
1. 上述三种形式之一 
2. object.wait() object.notify() object.notifyAll()
1 和 2 都是隐式实现


### 加了偏向锁之后，对象的 hashcode 存在哪？

## 偏向锁？锁的升级与对比
Java SE 1.6中锁有4种状态，级别从低到高依次是：无锁状态，偏向锁，轻量级锁，重量级锁

### 为什么要有多种状态的锁？
为了减少获取锁和释放锁带来的性能损耗


# 隐式锁 vs 显示锁

| | 使用便捷性 | 灵活性 | 可中断的锁 | 超时获取锁 | 互斥/共享 | 阻塞 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| Synchronized | 隐式获取/释放锁，代码简洁 | 固化，自动执行 | No | No | 只互斥 | 阻塞 |
| Lock | 显示获取/释放锁，注意编码技巧 | 灵活，手动控制 | Yes | Yes | 可互斥，可共享 | 可非阻塞 |

可中断的锁：在获取锁的过程中或在同步队列中，可响应中断

超时获取锁：如果线程在超时时间内没有获取到锁，则返回

# 参考
《浅谈偏向锁、轻量级锁、重量级锁》https://www.jianshu.com/p/36eedeb3f912