# 指令序列的重排序
## 为什么要对指令进行重排序？提高性能
为了提高执行效率，提高性能。



```
举个不恰当的例子：
1. a=1
2. b=2
3. a = a + 2
```



如果按照1，2，3的顺序执行，那就是把 a 读入寄存器-赋值-写回，把 b 读入寄存器-赋值-写回，把 a 读入寄存器-加法-写回。`《a 读入寄存器发生了2次》`
可以讲执行顺序调整为1，3，2，这样的话，把 a 读入寄存器-赋值-加法-写回，把 b 读入寄存器-赋值-写回。`《a 读入寄存器发生了1次》`

## 在什么地方发生了指令重排？编译器和处理器
1. 编译器重排，重排的是语句（Java 中是.class字节码）
2. 处理器（重排的是机器指令）
    1. 指令级并行技术：将多条指令重叠执行。如果程序语句间无数据依赖，处理器可以改变对应的机器指令的执行顺序，进一步可能通过指令级并行技术来重叠执行多条指令。
    2. 内存读写重排序。处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是乱序执行。

> 对处理器两种重排的理解。
处理器要执行的指令放在高速缓存中，它可以分析这些指令，通过重排来重叠执行（2.1）。

### CPU 写缓冲
#### CPU 为什么要进行写缓冲？减少等待写产生的停顿，提高执行效率
有了写缓冲区，可避免 CPU 停顿下来等待写内存。
CPU 将数据写入写缓冲区。
批处理方式刷新写缓冲区。
合并写缓冲区对同一地址的多次写。
减少对内存总线的占用。
> 写缓冲区只对自己的 CPU 可见
产生的问题：CPU 对内存的读写操作顺序，与实际上发生的内存读写顺序不一致。
比如：CPU 先写缓冲后读内存，但内存实际上先执行了读然后才发生了写，因为写缓冲的写是滞后的。

## 从源代码到指令的整个流程
源代码 --> 编译器语句重排 --> 指令级并行重排 --> 内存读写重排 --> 最终执行的指令序列